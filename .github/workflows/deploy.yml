name: From Docker build and push to AWS EC2

on:
  push:
    branches: [main]
  pull_request:
    branches: [test]
      
permissions:
  id-token: write
  contents: read

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
          
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
          
      - name: Building TEST image
        run: docker build -t ${{ vars.DOCKER_REPO }}:latest .
      
      - name: Push LATEST version
        if: success()
        run: docker push ${{ vars.DOCKER_REPO }}:latest
          
  deploy-to-aws:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4.3.1
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHub-OIDC
          role-session-name: GreenHaven
          aws_default_region: ${{ vars.AWS_REGION }}

      - name: Create Secrets Manager secret (if not exist)
        run: |
          SECRET_VALUE=$(cat << EOF
          {
            "db_user": "${{ secrets.DB_USER }}",
            "db_password": "${{ secrets.DB_PASSWORD }}",
            "db_name": "${{ secrets.DB_NAME }}"
          }
          EOF
          )
          
          aws secretsmanager create-secret \
            --name "flask/database-credentials" \
            --description "Database credentials for Docker Compose application" \
            --secret-string "$SECRET_VALUE" \
            --region ${{ env.AWS_REGION }} \
            2>/dev/null || \
          aws secretsmanager update-secret \
            --secret-id "flask/database-credentials" \
            --secret-string "$SECRET_VALUE" \
            --region ${{ vars.AWS_REGION }}
          
          echo "Secrets Manager secret created/updated successfully"

      - name: Validate CloudFormation template
        run: |
          echo "Current directory: $(pwd)"
          echo "Template file check:"
          if [ -f "infrastructure/template.yml" ]; then
            echo "Template file found"
            aws cloudformation validate-template \
              --template-body file://infrastructure/template.yml
          else
            echo "Template file not found at: $(pwd)/infrastructure/template.yml"
            exit 1
          fi
        
      - name: Validate CloudFormation template
        run: |
          aws cloudformation validate-template \
            --template-body file://infrastructure/template.yml

      - name: Deploy CloudFormation stack
        run: |
          aws cloudformation deploy \
            --template-file infrastructure/template.yml \
            --stack-name main \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --parameter-overrides \
              KeyPairName=${{ secrets.KEY_PAIR_NAME }} \
              CertificateArn=${{ secrets.CERTIFICATE_ARN }} \
            --tags \
              Project=my-app-stack \
              Environment=Production \
              ManagedBy=GitHubActions
            --debug

      - name: TESTING PHASE
        id: stack-outputs
        run: |
          LB_URL=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='LoadBalancerURL'].OutputValue" \
            --output text)
          echo "lb_url=$LB_URL" >> $GITHUB_OUTPUT
          
          LB_DNS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='LoadBalancerDNS'].OutputValue" \
            --output text)
          echo "lb_dns=$LB_DNS" >> $GITHUB_OUTPUT

      - name: Wait for application to be ready
        run: |
          echo "Waiting for application to be ready..."
          LB_URL="${{ steps.stack-outputs.outputs.lb_url }}"
          
          # Wait up to 10 minutes for the application to respond
          timeout 600 bash -c '
            until curl -k -s "$0" | grep -q "health\|login\|index"; do
              echo "Waiting for application to respond..."
              sleep 30
            done
          ' "$LB_URL"
          
          echo "Application is ready at: $LB_URL"

      - name: Run basic health check
        run: |
          LB_URL="${{ steps.stack-outputs.outputs.lb_url }}"
          
          # Test if application responds
          HTTP_STATUS=$(curl -k -s -o /dev/null -w "%{http_code}" "$LB_URL")
          
          if [ "$HTTP_STATUS" -eq 200 ] || [ "$HTTP_STATUS" -eq 302 ]; then
            echo "Health check SUCCESS (HTTP $HTTP_STATUS)"
          else
            echo "Health check FAIL (HTTP $HTTP_STATUS)"
            exit 1
          fi
