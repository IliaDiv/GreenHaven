name: From Docker build and push to AWS EC2

on:
  push:
    branches: [main]
  pull_request:
    branches: [test]
      
permissions:
  id-token: write
  contents: read

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
          
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
          
      - name: Building TEST image
        run: docker build -t ${{ vars.DOCKER_REPO }}:latest .

      - name: Running docker-compose
        env:
          DB_ROOT: ${{ vars.DB_ROOT }}
          DB_NAME: ${{ vars.DB_NAME }}
          DB_USER: ${{ vars.DB_USER }}
          DB_PASSWORD: ${{ vars.DB_PASSWORD }}
          DB_HOST: localhost
        run: |
          docker compose up -d
          sleep 10
          
          echo "Checking Flask app status..."
          docker exec -T flask-app ps aux | grep python || echo "Python process not found"
          
          echo "Flask logs:"
          docker logs flask-app

          if ! docker-compose exec -T flask-app curl -f http://localhost:5000/health 2>/dev/null; then
            echo "⚠️ Flask not responding, checking why..."
            docker exec -T flask-app python app.py &
            sleep 5
          fi

      - name: Test Flask healthcheck
        run: |
          curl -f http://localhost:5000/
          echo "Main endpoint are healthy"
      
      - name: Push LATEST version
        if: success()
        run: docker push ${{ vars.DOCKER_REPO }}:latest

      - name: Cleanup
        run: |
          docker compose down
          docker system prune -f
          
  deploy-to-aws:
    runs-on: ubuntu-latest
    needs: [docker]
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4.3.1
        with:
          aws-region: eu-central-1
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHub-OIDC
          role-session-name: RealizingDocker
          aws_default_region: eu-central-1

      - name: Create SSM Parameters (if not exist)
        run: |
          aws ssm put-parameter \
            --name "/docker-compose/db_user" \
            --value "${{ vars.DB_USER }}" \
            --type "String" \
            --overwrite || echo "Parameter already exists"
          
          aws ssm put-parameter \
            --name "/docker-compose/db_password" \
            --value "${{ vars.DB_PASSWORD }}" \
            --type "SecureString" \
            --overwrite || echo "Parameter already exists"
          
          aws ssm put-parameter \
            --name "/docker-compose/db_name" \
            --value "${{ vars.DB_NAME }}" \
            --type "String" \
            --overwrite || echo "Parameter already exists"

          aws ssm put-parameter \
            --name "/docker-compose/db_root" \
            --value "${{ vars.DB_NAME }}" \
            --type "String" \
            --overwrite || echo "Parameter already exists"

      - name: Validate CloudFormation template
        run: |
          aws cloudformation validate-template \
            --template-body file://infrastructure/template.yaml

      - name: Deploy CloudFormation stack
        run: |
          aws cloudformation deploy \
            --template-file infrastructure/template.yaml \
            --stack-name main \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --parameter-overrides \
              KeyPairName=${{ secrets.KEY_PAIR_NAME }} \
              CertificateArn=${{ secrets.CERTIFICATE_ARN }} \
            --tags \
              Project=MyApp \
              Environment=Production \
              ManagedBy=GitHubActions

      - name: TESTING PHASE
        id: stack-outputs
        run: |
          LB_URL=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='LoadBalancerURL'].OutputValue" \
            --output text)
          echo "lb_url=$LB_URL" >> $GITHUB_OUTPUT
          
          LB_DNS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='LoadBalancerDNS'].OutputValue" \
            --output text)
          echo "lb_dns=$LB_DNS" >> $GITHUB_OUTPUT

      - name: Wait for application to be ready
        run: |
          echo "Waiting for application to be ready..."
          LB_URL="${{ steps.stack-outputs.outputs.lb_url }}"
          
          # Wait up to 10 minutes for the application to respond
          timeout 600 bash -c '
            until curl -k -s "$0" | grep -q "health\|login\|index"; do
              echo "Waiting for application to respond..."
              sleep 30
            done
          ' "$LB_URL"
          
          echo "Application is ready at: $LB_URL"

      - name: Run basic health check
        run: |
          LB_URL="${{ steps.stack-outputs.outputs.lb_url }}"
          
          # Test if application responds
          HTTP_STATUS=$(curl -k -s -o /dev/null -w "%{http_code}" "$LB_URL")
          
          if [ "$HTTP_STATUS" -eq 200 ] || [ "$HTTP_STATUS" -eq 302 ]; then
            echo "Health check SUCCESS (HTTP $HTTP_STATUS)"
          else
            echo "Health check FAIL (HTTP $HTTP_STATUS)"
            exit 1
          fi
